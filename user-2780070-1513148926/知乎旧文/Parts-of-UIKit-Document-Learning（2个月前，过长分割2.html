<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Parts of UIKit Document Learning（2个月前，过长分割2</title>
    <style type="text/css" media="all">
      body {
        margin: 0;
        font-family: "Helvetica Neue", Helvetica, Arial, "Hiragino Sans GB", sans-serif;
        font-size: 14px;
        line-height: 20px;
        color: #777;
        background-color: white;
      }
      .container {
        width: 700px;
        margin-right: auto;
        margin-left: auto;
      }

      .post {
        font-family: Georgia, "Times New Roman", Times, "SimSun", serif;
        position: relative;
        padding: 70px;
        bottom: 0;
        overflow-y: auto;
        font-size: 16px;
        font-weight: normal;
        line-height: 25px;
        color: #515151;
      }

      .post h1{
        font-size: 50px;
        font-weight: 500;
        line-height: 60px;
        margin-bottom: 40px;
        color: inherit;
      }

      .post p {
        margin: 0 0 35px 0;
      }

      .post img {
        border: 1px solid #D9D9D9;
      }

      .post a {
        color: #28A1C5;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="post">
        <h1 class="title">Parts of UIKit Document Learning（2个月前，过长分割2</h1>
        <div class="show-content">
          <p>配置app窗口<br></p><p>你的应用需要制定一个试图控制器给window的rootViewController属性在application:didFinishLaunchingWithOptions:返回前如果你的app有一个特定的主storyboard，storyboard中的初始化试图控制器会被自动配置为窗口的root控制器</p><p>在你的app控制器中实现的方法</p><p>对于一个支持横屏的视图控制器，你不需要做任何事。默认而言，试图控制器支持所有的方向。然而，因为UIInterfaceOrientationPortrait并不包含的app属性列表的UISupportedInterfaceOrientations键值中，app并不支持竖屏，让横屏成为唯一支持的方向。可参见View Controller Programming Guide看更多的信息</p><p>在一个ios5或以下版本中要支持横屏的，必须重载手榴弹Auto肉塔特ToInterfaceOrientation:方法。</p><p>设计你的视图</p><p>当设计一个只支持横屏的界面时，你在编辑【wAny hAny】的过程中处理大部分变化。除非你的app只支持ios8或更高版本，否则你应该避免在编辑【wCompact hCompact】或【wAny hCompact】尺寸时做任何变化处理。在ios7或更低版本中变化不会被自动适配。对于只适配iPhone 6Plus的变化应该在编辑【wRegular hCompact】尺寸时设定。</p><p>界面编辑器可以在预览辅助里模拟横屏元素，随着编辑器显示。在辅助编辑器中选择Preview》Storyboard Name从跳出的菜单中</p><p>参加图片。。。</p><p>模拟设备可以通过+号来添加。</p><p>。。。</p><p>让app可以在登陆设旋转为竖屏</p><p>尽管app是以横屏来显示内容的，某些特定的页面或许用竖屏显示会更好。等UIKit检测到设备的朝向发生改变时，它使用UIApplication对象并且root视图控制器会决定是否一个新的朝向是可行的。如果对象都支持新的方向，自动调整就会发生。否则方向改变会被忽略。</p><p>默认来说，UIApplication对象从节目源中获取它支持的方向通过检测app属性列表中的UISupportedInterfaceOrientations键值。你可以重载这个行为通过实现application：supportInterfaceOrientationsForWindow：方法在application代理中。这个支持方向的返回值只有在app已经完成登录后生效。因此你可以通过这个方法在登录后支持设定不同的方向。</p><p>。。。</p><p>回调视图控制器默认支持所有的方向。除了UIApplication对象在app层级支持阻止横屏转竖屏，对于只支持横屏显示的控制器你需要实现supportedInterfaceOrientatioins</p><p>图</p><p>系统只会请求app的窗口的root试图控制器支持的方向。你或许会发现如果你是调用的一个容器内的试图控制器你无需实现它的supportedInterfaceOrientations方法，类似UINavigationController，等它决定支持方向时无需牵扯其子类。在这种情况下，navigation控制器的代理必须实现navigationControllerSupportedInterfaceOrientation：。如果你的app需要支持ios6，你需要用UINaviagationController来代替并且重载supportedInterfaceOrientation如图示的那样。</p><p>图。</p><p>27.本地和远程推送编程指南（Local and Remote Notification）（一个有意义的问题，探讨Notification的后台实现机制）</p><p>本地推送和远程推送是两种用户推送的方式，是通过广播推送和键-对象观察推送（由NSNotificationCenter类来管理）。用户推送让一个app无需再前台运行就可以通知用户。这些通知可以是信息，一个临近的日历事件，或是在远程服务器上的新数据。当时通过操作系统和用户推送信息来呈现时，无论是本地推送还是远程推送，感受起来都是一样的。它会显示一个弹出框信息或者添加一个警示数字在app图标上。当信息弹出或警示数字显示时可以发出一个声音。</p><p>当接受到用户通知后，用户可以点击登录相关的app来了解详情信息。用户也可以忽略推送通知，这样app就不会被激活。</p><p>概况</p><p>本地和远程推送对于用户来说是一样的，但是他们服务于不同情境你需要不同的配置和管理他们。</p><p>本地和远程推送对比（contrasted）</p><p>许多app基于时间或连网环境来应对用户感兴趣的事件发生且app没有在前台运行时。本地和远程推送允许app通知用户在这些事件发生时。</p><p>本地和远程推送服务于不同的设计需求，如下所述：</p><p>。一个本地推送是被app本身来计划调度以及发送的，无需互联网环境</p><p>。一个远程推送，也本成为推送通知（push notification），是从外部设备发送来接收的。它的信息源于一个由你来管理的远程服务器-app的提供方-通过Apple Push Notification service（APNs）来推送信息到用户设备上。</p><p>相关章节：Local and Remote Notification in Depth</p><p>注册，调度和处理用户推送</p><p>系统将要推送一个本地通知，app先注册推送类型（在ios8以及后续版本），创造一个本地推送对象（使用UILocalNotification或NSUserNotification），指派它发送的日期和事件，定义呈现的细节，并且任务调度它以计划发送。要实现一个远程推送，app首先要注册推送类型，然后提供其通过操作系统获取的特定的设备token。</p><p>当操作系统推送一个本地通知或一个远程通知时，目标app没有运行在前台，它可以通过一个弹出框或icon徽章数字或声音来呈现推送。如果有一个推送弹出框并且用户点击了动作按钮（或者是移动了动作 滚动条），app通过本地推送对象或远程推送装在（payload）登录并调用一个方法。如果app正在前台运行时推送抵达，app代理会接受一个本地或远程推送。</p><p>在ios8以及更高版本，用户推送可以包含定制的动作。同样，基于定位的本地推送可以本发出当用户抵达一个特定的地理坐标时。</p><p>相关章节：Registering，Scheduling and Handling User Notifications</p><p>Apple Push Notification Service(APNs)</p><p>Apple Push Notification service（APNs）将远程推送传递给拥有对应app并且注册了要接受推送信息的设备上。每一个设备上的app会通过指派一个编译后的IP链接来关联服务和接受推送来建立一个持久化的链接。（Providers connect with APNs through a persistent and secure channel while monitoring incoming data intended for their client apps）。当新的数据抵达app时，提供方通过APNs的同道来推送一个推送，这个推送将抵达指定的设备。</p><p>APNs提供方的API是异步的，从2015 12月开始，使用http/2来发送远程推送请求从你的提供服务器到APNs。提供方封装每个发出的推送并将它通过这个连接APNs的通道发出。</p><p>相关章节：Apple Push Notification Service，APNs Provider API</p><p>远程推送的安全资质</p><p>要为app开发和部署一个远程推送服务器，你需要从Member Center获取一个或多个SSL证书。从2015年12起，基于HTTP/2的提供API让你可以通过单一证书来实现开发和部署环境。另外，这个证书不仅可以用于发送推送给初选的app（被bundleID识别了的）也可以与Apple Watch相关的后台VoIP的服务。</p><p>相关章节：Provisioning and Development</p><p>前提条件（Prerequisites）</p><p>App Programming Guide for IOS描述了编写IOS app的技巧</p><p>对于本地推送以及远程推送的客户端部分，假定你以及熟悉了app的ios开发知识。对于远程推送的提供服务器部分，TLS/SSL以及sockets流相关的知识有一定作用。</p><p>同样可见</p><p>下述文档提供了背景信息</p><p>App Distribution Quick Start描述了如何在Xcode中创建一个团队的证书文件来允许APNs</p><p>Configuring Push Notifications在App Distribution Guide中的，描述了从Member Center中获取APNs证书的步骤</p><p>Entitlement Key Reference文档描述了所需的特定的权限用来接收远程推送的</p><p>你或许会发现这些额外的信息对于理解和实现本地和远程推送有所帮助</p><p>。Notification Essential 在App Programming Guide for watchOS中描述了Apple Watch中如何支持用户推送</p><p>。UILocalNotification，UIApplication，an和UIApplicationDelegate文档索引中描述了本地和远程的API用于客户端的API</p><p>。NSApplicatoin和NSApplicatinDelegate Protocol的文档索引描述了远程推送中的客户端的API在OS X系统中的</p><p>。Security Overview描述了使用IOS和OS X系统的安全技术和技巧</p><p>。RFC 5246是一个标准的TLS协议</p><p>在数据提供方和Apple Push Notification service之间的安全通信需要 Transport Layer Security（TLS）或它的底层，Secure Sockets Layer（SSL）相关的知识。可以参见一些网上的或书籍来了解更多相关知识。</p><p>更多关于如何使用OS X来推送信息通知给网站访问者的内容，可以参见Configuring Safari Push Notifications 在Notification Programming Guide for Websites（web 微信就是一个应用场景）</p><p>对于处理你遇到的发送和接收远程推送的问题案例，可以参见 Technical Note TN2265，Troubleshooting Push Notifications。</p><p>28.设定一个导航条填充颜色让它与你的主体色相匹配</p><p>Q：我如何来选定一个bar ting color来匹配我的app的底色或主题色</p><p>A:从IOS7开始，navigation bars，tab bars和tool bars（一般被较为bars）被设定为了默认半透明的。一个半透明的bar混合了它的barTintColor和灰色在将它与系统定义的透明度值结合来产生一个最终用于将其盖在内容上的背景色</p><p>。这对于那些想在app中保持颜色稳定的开发者提供了挑战，因为他们必须指望内容的颜色传递到半透明的bar下面在选定了一个bar tint 颜色时。最近更新的ios7通过增加前面所提到的系统定义的透明度值来减缓这个位码头、最终的结果是一个定制的bar ting color出现的越透明，越能给予开发者对于最终颜色的更好控制</p><p>想设定一个与给定颜色匹配的bar tint color，你传递给setBarTintColor：方法的颜色值需要考虑ios对于bar的透明度（？木太懂该如何操作，貌似是在说bar默认会带有一个透明度，你设定bartintcolor时需要考虑到这一点，而且这个透明度是无法通过手动改变的）。同样要注意的是，你通过alpha设定传递给颜色的值会被忽略，因为ios控制器已经实现了整体的半透明效果</p><p>达成最终正确的颜色效果可能需要许多次尝试。你同样需要把app内容传递到bar下面的部分考虑在内。（e.g photos or text）（这里的意思是说如果bar下面有内容，因为其半透明特性所以会产生一些影响）</p><p>一个开始点是将每个RGB通道黑化0.12（减0.12）。例如</p><p>从一个给定颜色生成一个bar tint 颜色（应该就是所谓的透明化？？？）</p><p>UIColor *corporateColor = [UIColor colorWithRed:0.20 green:0.40 blue:0.20 alpha:1.0];</p><p>UIColor *barTintColor = [UIColor colorWithRed:0.08 green:0.28 blue:0.08 alpha:1.0];</p><p>如果开始饿颜色值已经小于0.12了，您需要黑化其他通道值大于0.12 ，比如</p><p>UIColor *corporateColor = [UIColor colorWithRed:0.04 green:0.40 blue:0.20 alpha:1.0];</p><p>UIColor *barTintColor = [UIColor colorWithRed:0.00 green:0.24 blue:0.04 alpha:1.0];</p><p>同样的，在达成最终效果前你需要实现多次黑化来测试（ ~~~~~~ 貌似是一个不完全可靠的解决方案）；</p><p>29.IOS多窗口显示编程指南（multiple display）</p><p>每一个iOS app都有一个窗口来处理当前展示的用户界面。尽管这个窗口提供了重要功能，大部分app都无需接触它。通常而言，只有app需要支持一个额外显示时需要与窗口打交道。</p><p>概况</p><p>在iOS中，window对象包含了app的视图，管理设备显示上的内容呈现。window与呈现在用的特定设备显示的屏幕对象相关。如果你的app允许用户通过一个额外的display来浏览内容，你可以创建一个额外的window对象来管理在那个display上呈现的内容</p><p>windows为app提供了重要的功能</p><p>除了包含app的可视内容，windows同样与发送触控事件给视图以及响应方向改变相关。一个window的相关屏幕对象提供了关于当前正在使用设备显示的信息。当你使用storyboards来定义用户界面时，主storyboard会自动设定window来管理设备上显示的内容。</p><p>相关章节：Understanding Windows and Screens</p><p>一个额外的window用以支持一个额外的display</p><p>如果你的app支持一个额外的设备显示，你需要创建一个独立的window对象来呈现要显示的内容。你可以在两个display里面呈现相同内容-这个特性被成为镜像（mirroring）并且它是默认发生的-或者你可以在每个display里面显示不同的内容</p><p>相关章节：Presenting Content on an External Display</p><p>同样可见</p><p>App Programming Guide for IOS描述了IOS app的基础结构并且提供了编码指导以及一些最佳实例来帮助开发更好的app</p><p>AirPlay Overview描述了如果提供AirPlay-基于设备匹配多媒体到iOS上</p><p>UIWindow Class Reference描述了UIWindow类的编程</p><p>UIScreen Class Reference描述了UIScreen类相关的编程</p><p>30.阻止视图旋转</p><p>Q:app支持自动旋转，但是在特定界面需要锁定方向。如何实现</p><p>A:当系统决定了界面要旋转时，自动旋转通过应用的window来讲旋转应用。window会调整它的bounds来适应新的方向并将这个变化通过视图的继承关系传递到子类中去，是通过调用每个来得-viewWillTransitionToSize：withTransitionCoordinator：方法来实现的。（app的机制貌似很多都是自下而上，从最外层容器开始，然后依次调用内层容器的方法来进行传递，调用执行方法前可能会调用验证方法）。这个方法提供了一个坐标转换对象（transition coordinator object）包含了窗口当前形态和变化后形态的细节，可以通过调用-targetTransform方法来获取。你的视图控制器可以将合适的转换信息传递给目标视图。这样可以使自动旋转的传递失效让你的页面保持固定在当前的方向。</p><p>提示：在早期的ios版本中，通过指定一个视图为应用窗口的子视图可以将一个视图剥离自动旋转。因为改变自动旋转的底层实现，这个技术在ios8以及更新的版本中不适用了</p><p>- (void)viewWillLayoutSubviews</p><p>{</p><p>[super viewWillLayoutSubviews];</p><p>self.notRotatingView.center = CGPointMake(CGRectGetMidX(self.view.bounds), CGRectGetMidY(self.view.bounds));</p><p>}</p><p>- (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id)coordinator</p><p>{</p><p>[super viewWillTransitionToSize:size withTransitionCoordinator:coordinator];</p><p>[coordinator animateAlongsideTransition:^(idcontext) {</p><p>CGAffineTransform deltaTransform = coordinator.targetTransform;</p><p>CGFloat deltaAngle = atan2f(deltaTransform.b, deltaTransform.a);</p><p>CGFloat currentRotation = [[self.notRotatingView.layer valueForKeyPath:@"transform.rotation.z"] floatValue];</p><p>// Adding a small value to the rotation angle forces the animation to occur in a the desired direction, preventing an issue where the view would appear to rotate 2PI radians during a rotation from LandscapeRight -&gt; LandscapeLeft.</p><p>currentRotation += -1 * deltaAngle + 0.0001;</p><p>//下面这一行的设定是固定方向的关键代码</p><p>[self.notRotatingView.layer setValue:@(currentRotation) forKeyPath:@"transform.rotation.z"];</p><p>} completion:^(idcontext) {</p><p>// Integralize the transform to undo the extra 0.0001 added to the rotation angle.</p><p>CGAffineTransform currentTransform = self.notRotatingView.transform;</p><p>currentTransform.a = round(currentTransform.a);</p><p>currentTransform.b = round(currentTransform.b);</p><p>currentTransform.c = round(currentTransform.c);</p><p>currentTransform.d = round(currentTransform.d);</p><p>self.notRotatingView.transform = currentTransform;</p><p>}];</p><p>}</p><p>注意点</p><p>上述技术只能应用与那些你的试图控制器直接对其布局负责的情况。（比如试图控制器的子类等）。一个视图控制器不应该去修改其他坐标系体系的视图，那些其他坐标系体系的视图由其父视图控制器来管理。如果你需要组织一个视图控制器旋转，可参见Controlling What Interface Orientations Are Supported在View Controller Programming Guide for IOS中</p><p>自动布局</p><p>修改视图的transform属性对于自动布局是不推荐的。如果你使用了自动布局，视图元素与transform相关的将被应用到一个自动布局失效的xib文件中，然后在运行时，加载xib文件来程序化的添加视图的集成关系</p><p>Listing 2 Loading notRotatingView from a xib file.</p><p>// Connected to the root view in the xib.</p><p>@property (nonatomic, strong) IBOutlet UIView *notRotatingView;</p><p>- (void)viewDidLoad</p><p>{</p><p>[super viewDidLoad];</p><p>// Load the notRotatingView from a xib, which has Autolayout disabled.</p><p>[[UINib nibWithNibName:@"NotRotatingView" bundle:[NSBundle bundleForClass:self.class]] instantiateWithOwner:self options:nil];</p><p>[self.view addSubview:self.notRotatingView];</p><p>}</p><p>31.防止状态栏挡住视图</p><p>Q:在IOS 7中如何防止状态栏挡住视图</p><p>。。。</p><p>32.在app离开激活状态时保存屏幕的亮度</p><p>Q:为什么在我设定的UIScreen brightness属性时无法保存屏幕的亮度，在我的app离开激活状态时</p><p>A:操作系统会存储用户原始的亮度设定在它认为正确的时机。存储亮度不是开发者的职责，并且可见在你的app离开前台时就无法设定亮度了。这是一个系统设定。</p><p>33.滚动视图编程指南</p><p>在内容需要被显示和操作的部分没法完全展现在屏幕上时，app一般就会采用滚动视图。滚动视图（Scroll）有两个主要目的：</p><p>。让用户可以抓拽他们想显示的内容区域</p><p>。让用户可以通过捏合手势来快速调整内容位置</p><p>下述图片支出了UIScrollView类的一个典型应用。子视图是一个UIImageView包含了一个一个男孩的图片。当用户再屏幕上抓拽手指，图片的展示内容部分移动，正如在下图中看到的一样，滚动提示器会显示。当用户松开手指，提示器会消失。</p><p>概览</p><p>UIScrollView类提供了下述功能</p><p>。滚动内容无法完全匹配整个屏幕</p><p>。缩放内容，让你的app支持标准的捏合手势来缩放内容</p><p>。在特定时间限制滚动视图到一个单一的内容屏幕（paging mode）</p><p>UIScrollView类不包含特殊定义的视图；相对而言它可以滚动它的子视图。这个简单模式是可行的因为ios对于初始化滚动视图无需额外的控制。</p><p>基础滚动视图是最简单的实现</p><p>通过拽和弹手势来滚动无需子类和代理实现。通过程序来设定UIScrollView实例的内容大小，完整的用户界面可以通过界面构建器来实现。</p><p>相关章节：Creating and Configuring Scroll Views</p><p>要支持捏合区域手势，你需要使用代理</p><p>如果要添加基本的捏合区域支持那么要求你的滚动视图使用代理。需要实现UIScrollVIewDelegate协议并且实现一个代理方法来支持滚动视图子视图的变化。你童谣需要定义一个或者同时实现最小的和最大的缩放倍数元素。</p><p>如果你的app需要支持双击缩放，两个手指的触控来方法或者简单的单触滚动或平移（除了标准的捏合手势外）你需要在内容视图中实现代码来处理这些功能</p><p>相关章节：Basic Zooming Using the Pinch Gestures</p><p>要支持捏合缩放以及触控区域，你需要在内容视图里实现代码</p><p>如果你的app需要支持双击缩放或两个手指触摸来放大或者是简单的一个手指滚动或平移（除了标准的捏合外），你需要在你的内容视图中实现代码</p><p>相关章节：Zooming by Tapping</p><p>要支持Paging模式，你只需要三个子视图</p><p>要支持paging模式，没有额外的子类和代理需要实现。你只需要简单的定义内容大小并且开启paging模式。你可以只使用3个子视图来实现最简单的paging应用，这样节省了内存并增加了可操作性</p><p>相关提示：Scrolling Using Paging Mode</p><p>前提</p><p>在阅读这个指导前，先阅读App Programming Guide for IOS 来理解开发iosapp的基本技巧。同样可以考虑阅读View Controller Programming Guide for IOS来了解一些基本的试图控制器的信息</p><p>怎么使用这个文档</p><p>这个文档中剩余的章节来帮你实现一些复杂的任务比如处理 实时缩放技术，理解代理的角色以及信息序列，以及在视图中聚集（nest）滚动视图</p><p>同样可见</p><p>你可以找到一些简单的范例工程</p><p>。Scrolling demonstrate basic scrolling</p><p>。PageControl demonstrates using scroll views in paging mode</p><p>。ScrollViewSuite of sample projects。有一些高级的返利可以展示像其他有意义高级工程一样的触控滚动功能，包括允许大量详细的图片用一个内存搞笑的方式来显示。（重用的范例）</p><p>34.设置xcode自动管理证书</p><p>Q:如何使用Xcode来自动管理证书</p><p>A:对于许多需要管理老app的开发者可能需要指定特定的项来做签名设置；这个Q&amp;A讨论了如何使用Xcode的自动证书管理。这个主题对于IOS和MACapp开发同样适用</p><p>Xcode自动证书管理对于开发和发布的代码签名都是推荐的方式。换而言之，这是一个推荐的方式来为企业或个人开发者账号来设定他们的项目。所有的开发者在接触其他技术前可能都需要了解这里介绍的代码签名实例。同样，这是在App Distribution Guide中的文档。选定了自动签名方式意味着以后你不要再纠结于Code Signing Identity和Provisioning Profiles的设定，它可以让Xcode帮你做出最佳选择</p><p>根据下述步骤来使用Xcode的自动签名</p><p>。设定工程级别的签名设定到默认值</p><p>1.导航到工程里-》Build Setting项</p><p>2.为所有的构建配置来设定Provisioning Profile设定为Automatic</p><p>3.设定Code Signing Identity设定</p><p>。在iOS工程里为所有的编译配置设定IOS Developer</p><p>。设定Mac Developer或Developer ID为合适值，对于os x的工程</p><p>。设定target的签名配置为默认值</p><p>1.设定traget&gt;General&gt;Team为none</p><p>重要：对于Mac apps，同样需要设定Target》General》“Signing”为None</p><p>2.为所有的编译配置修改Provisioning Profile设置为Automatic</p><p>3.设置Code Signing Identity设置</p><p>在target中设定</p><p>返回到Target》General页签下来设定Team</p><p>1.对于mac apps，设定target》general》“signing”到mac app store</p><p>2.设置 target》general》team为自己的team</p><p>提示：在设置签名为默认值前先设置Target》General》Team为None很重要，尽管之后依旧会设置team名</p><p>图</p><p>重要：最终，完整这些改变后，你需要重启xcode</p><p>一旦你切换摸到来让你的xcode管理应用的签名文件，capabilities需要添加到projiect中。当你使用xcode添加capabilities时，xcode会自动配置来使用它们。xcode会编辑entitlements和information属性列表让你可以根据需要添加特定的框架。对于采用的entitlements，xcode为你的团队创建签名文件也为你设置签名。xcode 创建一个百搭的App ID或一个明确的app id，根据需要，你可以开放你所选择的服务。</p><p>你可以在Member Center中使用呢App ID并且设置任何Xcode管理的签名文件。（这个章节不好翻译，大致描述的是在Member Center中签名的过程） 。Xcode 5需要你在Member Center中创建一个自己的发布证书。Xcode 6需要创建所需的任意证书。当Xcode创建一个发布证书时，发布证书文件是以text XC开头的，跟在App ID后面。如果你在使用一个百搭的App ID，发布证书的名字是 XC：*</p><p>35.iPad app的方向支持（Skip iPad‘s Centent）</p><p>大致也和app的一直，都是从容器开始，通过特定的方法路径来实现方向转换</p><p>36.ios的列表视图编程</p><p>关于iOS App的列表视图</p><p>列表视图通常是ios app中经常看到的多种形式的用户界面对象。一个列表视图通过滚动列表或多行来呈现数据内容的经常会被分成多个小结。</p><p>列表视图有许多目标：</p><p>。让用户可以通过继承的数据结构来导航</p><p>。来展现一列有索引的列表项</p><p>。用虚拟抽离的分组方式来显示详细的信息或操作项</p><p>。展示一个可选列表列的操作项</p><p>一个列表视图只包含一列并且只支持垂直方向滚动。它通过章节的方式由行组成。每个章节都可以有一个抬头和一个抬尾来显示文本或图片。然而，需要列表视图只有一个章节。程序上说，UIKit框架通过index数字号来定位行和章节：章节号的号码从0到n-1从列表的顶端到低端；行号从0到n-1在一个章节中。一个列表能够有它自己的头和尾。</p><p>概况</p><p>一个列表是UITableView类的一个实例，有两个基本的风格，plain和grouped。一个plain列表是一个连续的列表；一个grouped列表是一个有虚拟单独章节的列表。一个列表有一个数据源有时需要一个代理。数据源提供了构建章节和列表行视图所需要的数据。代表对象可以定制外观和特性。</p><p>相关章节：Table View Styles andAccessory Views</p><p>列表视图用cells来绘制行</p><p>一个列表是用cells来绘制行的-也就是，UITableViewCell对象。Cells是显示文件图片和其他类型内容的视图。他们可以有不同的背景视图对于常规和选定的状态。Cells同样可以有辅助（accessory）视图，它可以作为控制版来选定和设置选项。</p><p>UIKit框架定义了标准的cell样式，是用三个默认内容元素来布局的，main label，detail label和image。你也可以创造自己的定制cell来形成特定的app列表</p><p>当你在storyboard编辑器中配置了列表视图的属性时，你可以在两种cell内容中选择：静态cell和动态样式。</p><p>。静态cell。使用静态cell类用一系列的行，每一个行都有特定的布局来设计一个列表。使用静态cell时你知道列表在设计上看起来是什么样的，可以忽略掉需要显示的信息</p><p>。动态样式。使用动态样式是设计一个模板给cell。使用动态cell当多个cell必须保持一致的布局时。动态cell是在运行时由数据源管理的。</p><p>相关章节：Table View Styles and Accessory Views，A Closer Look at Table View Cells</p><p>响应选定行</p><p>当用户选定一行时（通过触碰），列表代理会通过一个信息被通知到。选定行所在的行索引和章节索引都会被传递给代理对象。它使用这种信息来在app的数据模型中来定位相符的对象。这个item可能是一个过程级别的继承对象作为一个体系里面的叶指针。如果这个item是处于一个过程层级，app显示一个新的列表视图。如果这个item是一个叶指针，那么app显示细节告诉选定的对象是在一个grouped-style列表中或者其他类似的视图中。（没翻译好，大致意思是分两种，一种是可展开的，一种是单独选定的）</p><p>相关章节：Navigating a Data Hierarchy with Table Views，Managing Selections</p><p>在编辑模式中，你可以添加 删除以及重新给行排序</p><p>列表可以进入一个编辑模式，在这个模式下，用户可以插入或删除行，或者可以重新用列表来定位它们。在编辑模式中，行会在行的左侧边缘显示一个绿色的加按钮或红色的减按钮来作为添加和删除。如果用户触碰一个删除错做，在一些列表视图中，横滑一行，一个红色删除按钮会出现，提示用户删除这一行。行可以被重新定位显示（在右侧边缘附近）一个由几个水平线组成的图片。当列表离开编辑模式时，插入，删除和重新排序操作选项都会隐藏。</p><p>当用户尝试去插入 删除或重新排序行时，列表视图会给代理和数据源发送一系列的操作指令</p><p>相关章节：Inserting and Deleting Rows and Sections，Managing the Reordering of Rows</p><p>使用一个storyboard创建一个列表视图</p><p>最简单和推荐的创建和管理一个列表视图的方式是在storyboard中使用一个标准的UITableViewController对象。如果你的app大量页面是基于列表视图的，可以使用Xcode Master-Detail Application的 模板。这个模板，包含了一个标准的初始化的UITableViewController类和一个storyboard来作为用户界面的模拟，包括定制视图和列表视图。在storyboard编辑器中，为列表视图选择一个或两个风格并设计其内容。</p><p>在运行时，UITableViewController创造一个列表视图并且制定它自己为代理和数据源。在它完成创建后，列表会询问数据源章节数量和每个章节的行数量，然后列表cell会绘制出具体行。数据源会被用于实现章节和行。</p><p>相关章节：Navigating a Data Hierarchy with Table Views，Creating and configuring a Table View</p><p>前提条件</p><p>在阅读文当前，你可以阅读Start Developing IOS Apps Today来了解一些开发技巧...</p><p>….</p><p>….</p><p>同样可见</p><p>范例工程</p><p>SimpleDrillDown project</p><p>Table View Animations and Gestures</p><p>37.ios的文本编程</p><p>ios平台提供了许多方式来在app中显示文本并且让用户可以编辑文本。它同样让用户可以在app视图中显示格式化的文本和网页内容</p><p>38.推送证书相关的问题</p><p>39.UIKit用户交互目录</p><p>40.滚动视图和自动布局</p><p>41.使用UIWebView来显示选定的文本类别</p><p>42.使用回退？（using unwind segues）</p><p>43.ios视图控制器目录</p><p>44.ios视图控制器编程</p><p>45.ios视图编程</p><p>46.ios7的快照</p><p>47.为什么UILocalizedIndexedCollation不会返回一个本地化的结果</p><p>48.为什么当文本输入框被选定时键盘不出现</p><p>49.为什么我的UIViewController不会跟着设备旋转</p><p>吐槽：真多呀。。。 一个晚上还木弄完，明天继续搞~~~</p><p>吐槽：都快弄完了，结果IOS10更新了，然后文档结构目录布局貌似改变了~~~~~~~ sick ： 2016.09.19</p>
        </div>
      </div>
    </div>
  </body>
</html>

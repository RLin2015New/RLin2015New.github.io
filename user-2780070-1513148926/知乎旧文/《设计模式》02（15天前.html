<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>《设计模式》02（15天前</title>
    <style type="text/css" media="all">
      body {
        margin: 0;
        font-family: "Helvetica Neue", Helvetica, Arial, "Hiragino Sans GB", sans-serif;
        font-size: 14px;
        line-height: 20px;
        color: #777;
        background-color: white;
      }
      .container {
        width: 700px;
        margin-right: auto;
        margin-left: auto;
      }

      .post {
        font-family: Georgia, "Times New Roman", Times, "SimSun", serif;
        position: relative;
        padding: 70px;
        bottom: 0;
        overflow-y: auto;
        font-size: 16px;
        font-weight: normal;
        line-height: 25px;
        color: #515151;
      }

      .post h1{
        font-size: 50px;
        font-weight: 500;
        line-height: 60px;
        margin-bottom: 40px;
        color: inherit;
      }

      .post p {
        margin: 0 0 35px 0;
      }

      .post img {
        border: 1px solid #D9D9D9;
      }

      .post a {
        color: #28A1C5;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="post">
        <h1 class="title">《设计模式》02（15天前</h1>
        <div class="show-content">
          <p>抛开刚刚看的SSG对SKT逆袭未成的比赛，上午看了一下第四章的 结构型模式<br></p><p>说实话，有点没看懂。有几个模式都体会不了它们的设计初衷和优势。结构型模式在框架体系中应用很广。我常用的netty中就有很多熟眼的细节代码，以前看SSH时对于还多内容也觉得是云里雾里，体会不了为什么要那么写，现在回想一下，很多都是契合了一些设计模式的规范。所以还是要好好学一下设计模式，因为这是学懂框架的前提。</p><p>对于设计模式，个人的感觉是在说遇到一些情况或者想解决一些情况时，有哪些可以复用的技巧。所谓模式，其实就是大家在解决这些问题是的经验。如果把自己设置在那个情景中，考虑到那些需要考虑的事，或许也能想出类似的解决办法。而设计模式这本书，正是把这些办法抽离出来，让它们可以学习和传播，提出特定概念，也为交流提供了便利。而且23个设计模式的特点，更像是一个个独立的大招，虽然也按三类来划分，但是各自的独立性其实很强。</p><p>回到到本书，两类模式看下来，感觉作者的考虑重心其实是偏在可移植性、复用（标准化）、代码协作、降低编译依赖性（这一点应该是受当时计算机性能所限导致的）这几个维度的。</p><p>上午看书成效有限。下午继续再把这一章节看一遍。</p><p><b>Adapter（适配器模式） -类/对象结构型模式 （或 wrapper）</b></p><p>针对处理的情况是，如果已经有了一些接口A，但是现在需要的是接口B，但是两者有很强的相关性，所以用适配器模式来把接口A转化成接口B（就像戴一个全遮帽子，带进去后眼睛去找眼睛，鼻子去找鼻子）</p><p>落实到实现层次有两种实现方式，一种是 类适配器，一般采取的是多继承的方式，然后显示表达B接口，隐式表达A接口，B接口的实现则根据逻辑用父类A的属性来实现。（这种是依赖于多继承的语言特性）</p><p>另外一种是 对象适配器，就是继承B接口，但是持有一个A对象，B接口实现时用A对象来做转化。</p><p>本质其实都是一样的，持有一个A，用A来填充B接口的实现。</p><p>猜想，对于基于已有工具包定义自己工具包，或者是用厂商接口来做自己事情时会比较多用这个模式。</p><p><b>Bridge（桥接模式）-对象结构型模式 （或 handle）</b></p><p>常规的实现方式是 抽象接口-》继承实现，抽象和继承的变化互相影响</p><p>桥接模式引入了一个imp类的概念，让抽象类持有一个imp对象，抽象实现时根据版本来调用imp提供的实现方法，同时，imp可以有多个子类的实现。</p><p>类似于 下面的结构</p><p>抽象接口-------》抽象接口实现所需的类</p><p>| |</p><p>| |</p><p>| 不同的底层实现</p><p>不同的接口实现类（通过调用持有的实现所需类来做具体实现）</p><p>优势：分离接口和实现部分，提高了可拓展性，实现细节对客户透明</p><p>（有一点像java里提倡的接口和实现分离的思想）</p><p><b>Composite（组合模式） -（对象结构型模式）</b></p><p>用来将对象组合成树形结构以表示“部分-整体‘的层次结构。组合模式使得用户对单个对象和组合对象的使用有一致性。</p><p>实现： basic类 -------- basic的子类composite，额外添加树形结构的操作接口（add remove iterator一类的）</p><p>组合模式在很多场景适用，类似于文本这种，部分-整体 层次结构很难区分时，需要对操作有一致性就可以用。</p><p><b>Decorator（装饰模式）-对象结构模型</b></p><p>动态给一个对象添加一些额外的责任。比生成子类更灵活（wrapper）（- -！我怎么没看出来）（貌似需要从编译的角度来考虑）</p><p>实现：basic类--------basic的子类docorator，通过basic雷初始化并且持有basic</p><p>（在系统控件实现上貌似有运用）</p><p><b>Fasade(外观模式)-对象结构型模式</b></p><p>貌似是定义了一个高级接口，这个接口专门用来管理系统的外观以及子系统的交互。有点像定义了一个主页的概念，然后子系统的外观和交互都由这个主页来完成。（可能是我用ios开发的缘故，对这个模式觉得很习以为常。。。。。。 其实就是无感。。。hah）</p><p>提高了子系统的可移植性，降低客户与系统的耦合</p><p><b>FlyWeight（享元模式）-对象结构型模型</b></p><p>运用共享技术有效的支持大量细粒度的对象（其实就是把能复用的东西抽离出来。）</p><p>适用情况是 程序运用了大量的对象，且对象的大多数状态为可变的外部状态，不依赖于对象标志。</p><p>实现： 将类的内容区分成内部状态和外部状态两种，内部状态为可以共享和复用的，外部状态为变化的部分。配合一个存储和管理内部共享的容器。初始化时，收集新的内部状态对象，然后再把这些内部状态对象去给包含外部状态的对象持有。（表述很麻烦，但是思想很简单，就是类似于 字符串共享池的概念，把常用的变化有限的内容用容器管理，需要用时不新建而从容器中直接拿取）</p><p><b>Proxy（代理模式）-对象结构型模式</b></p><p>就是持有一个指向对象的引用，并提供一种代理以控制对对象的访问。应用很广，IOS的asset对象就是一个典型。代理照片，持有访问照片对象的地址，并支持所有开放的对照片的操作。</p><p>实现：</p><p>代理类持有basic类的引用。代理类控制在适合的时机进行basic类的真正访问（也就是生成一个basic对象）。</p><p>暂时这样，出门了~</p>
        </div>
      </div>
    </div>
  </body>
</html>

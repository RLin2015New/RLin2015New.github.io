<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>《Java并发编程实战》-序及简介</title>
    <style type="text/css" media="all">
      body {
        margin: 0;
        font-family: "Helvetica Neue", Helvetica, Arial, "Hiragino Sans GB", sans-serif;
        font-size: 14px;
        line-height: 20px;
        color: #777;
        background-color: white;
      }
      .container {
        width: 700px;
        margin-right: auto;
        margin-left: auto;
      }

      .post {
        font-family: Georgia, "Times New Roman", Times, "SimSun", serif;
        position: relative;
        padding: 70px;
        bottom: 0;
        overflow-y: auto;
        font-size: 16px;
        font-weight: normal;
        line-height: 25px;
        color: #515151;
      }

      .post h1{
        font-size: 50px;
        font-weight: 500;
        line-height: 60px;
        margin-bottom: 40px;
        color: inherit;
      }

      .post p {
        margin: 0 0 35px 0;
      }

      .post img {
        border: 1px solid #D9D9D9;
      }

      .post a {
        color: #28A1C5;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="post">
        <h1 class="title">《Java并发编程实战》-序及简介</h1>
        <div class="show-content">
          <p>英文书名为《Java Concurrency in Practice》 </p><p>对于并发，一直是怀有崇敬之心的。学生时代时见识过各种锁给程序带来的非指数增长的理解难度，然而却也一直认为并发是现代计算机技术的精髓所在，它解放了软件和程序，使之不在受限于线性逻辑，丰富了整个计算机世界。</p><p>近期也与并发打交道颇多，最近在公司做的托管以及倒计时自动操作功能，在某种程度上就极大的增加了触发并发问题的概率，所以也使得原来非常简单的棋牌程序逻辑对于并发管理有了一定要求。现行采取的方案还是尽量把调度任务单线程化，对于可能出现并发的容器结构和操作上锁。还没有做性能测试，目前也不知道效果如何。对于程序的并发支持要求是成本与用户量的一个共同作用的结果，也牵扯到架构。简而言之就是，在用户量级没上去时，对于大部分程序可能是0并发支持要求，用户量上升到一定程度后，可以通过架构拓展分服结构来延缓这个问题，而在用户量到达较高层级后，提升对于程序并发能力的支持将有效降低成本。</p><p>序言中谈及的，本书共分为四个部分：</p><p>基础知识，介绍并发性和线程安全性的基本概念，总结了一些构建线程安全类的规则。</p><p>结构化并发应用程序，介绍如何用线程来提高并发应用程序的吞吐量或响应性。</p><p>活跃性、性能与测试，介绍如何确保并发程序执行预期任务以及获得理想效果。</p><p>高级主题，介绍显式锁、原子变量、非阻塞算法以及如何开发自定义的同步工具类。</p><p><br></p><p>1.想充分发挥多处理器系统的强大计算能力，最简单的方式就是使用线程。（换而言之，单线程的计算能力上限取决于单处理器；要提高程序整体速度，可以考虑提高单处理器性能，更优的策略是把要做的事情让不同线程执行达到并发。当然，并发执行这一点很有可能操作系统已经帮忙做了）</p><p>2.操作系统引入并发的原因是基于资源利用率、公平性以及便利性的考虑</p><p>3.但凡做事高效的人，总能在串行性与异步性之间找到合适的平衡，对于程序来说同样如此。</p><p>  串行因为不需要切换场景，所以单点执行效率更优；而异步则因为可以同时进行，整理更优。</p><p>4.使用多个线程有助于在单处理系统上获得更高的吞吐率。</p><p>5.考虑把长时间运行的任务放在一个单独的线程中运行</p><p>6.@NotThreadSafe标签和@ThreadSafe标签</p><p>7.注意并非只是容器对象才可能有并发问题，所有的非原子操作都可能有并发问题。简单如 a++这种。而花流程图，是很好的拆解出这类问题的办法</p><p>   如        a++的实质是    a -&gt;9 -》 a+1-&gt;10 -》a=10 ，如果此时另外线程刚好在第二环节访问a，那么拿到的a值依旧是9，就可能造成数据错乱</p><p>   所以这里要尤其注意对于货币等重要数值的异步保护</p><p>8.安全性的含义是，永远不发生糟糕的事情；活跃性则是，某件正确的事情最终会发生</p><p>9.框架通过在框架线程中调用应用程序代码将并发性引入到线程中。在代码中将不可避免地访问应用程序状态，因此所有访问这些状态的代码路径都必须是线程安全的。注意，web框架依旧是框架，对于web项目，如果并发操作到一定层级后，应该也需要注意线程的安全性。</p><p>10.远程对象也需要注意线程安全性。</p><p><br></p><p>第 1 章 简介</p><p>1.1 并发简史</p><p> 资源利用率、公平性、便利性</p><p>1.2 线程的优势</p><p>1.2.1 发挥多处理器的强大能力</p><p>1.2.2 建模的简单性</p><p>从某种角度来讲线程确实简化了整体模型，因为在一个线性结构中要完成多线程所做的事情复杂度讲极高。所以操作系统引入进程和线程的概念，从某种程度来说其实就是把这种底层复杂度给封装了。</p><p>1.2.3 异步事件的简化处理</p><p>单线程服务器应用程序必须使用非阻塞I/O</p><p>1.2.4 响应更灵敏的用户界面</p><p>把长时长任务放单独线程中</p><p>1.3 线程带来的风险</p><p>1.3.1 安全性问题</p><p>@ThreadSafe @NotThreadSafe</p><p>1.3.2 活跃性问题</p><p>安全性：永远不发生糟糕的事情  活跃性：某件正确的事情最终会发生</p><p>1.3.3 性能问题</p><p>如：服务时间过长、响应不灵敏、吞吐率过低、资源消耗过高或可伸缩性较低</p><p>1.4线程无处不在</p><p>框架通过在框架线程中调用应用程序代码将并发性引入到程序中。在代码中将不可避免地访问应用程序状态，因此所有访问这些状态的代码路径都必须是线程安全的。</p>
        </div>
      </div>
    </div>
  </body>
</html>

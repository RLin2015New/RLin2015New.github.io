<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Java重温-对象导论01</title>
    <style type="text/css" media="all">
      body {
        margin: 0;
        font-family: "Helvetica Neue", Helvetica, Arial, "Hiragino Sans GB", sans-serif;
        font-size: 14px;
        line-height: 20px;
        color: #777;
        background-color: white;
      }
      .container {
        width: 700px;
        margin-right: auto;
        margin-left: auto;
      }

      .post {
        font-family: Georgia, "Times New Roman", Times, "SimSun", serif;
        position: relative;
        padding: 70px;
        bottom: 0;
        overflow-y: auto;
        font-size: 16px;
        font-weight: normal;
        line-height: 25px;
        color: #515151;
      }

      .post h1{
        font-size: 50px;
        font-weight: 500;
        line-height: 60px;
        margin-bottom: 40px;
        color: inherit;
      }

      .post p {
        margin: 0 0 35px 0;
      }

      .post img {
        border: 1px solid #D9D9D9;
      }

      .post a {
        color: #28A1C5;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="post">
        <h1 class="title">Java重温-对象导论01</h1>
        <div class="show-content">
          <p>重读《Java编程思想》之对象导论一章，非常有感触。</p><p>几句特别印象深刻的话。</p><p>1.“我们之所以将自然界分解，组织成各种概念，并按照其含义分类，主要是因我们是整个口语交流社会共同遵守的协定的参与者，整个协议以语言的形式固定下来......除非赞成整个协议中规定的有关语言信息的组织和分类，否则我们根本无法交谈”。</p><p>这句话非常深刻，揭露了我们身而为人所接受的隐性规则-基础概念认同。这也是我们为什么把茶杯称为茶杯，把高温水的触感称之为烫的原因。因为它们是最基础的约定的，问题前提中已经给出了的信息定义。我以前写东西时比较喜欢用一些自己造的词，自己意识到了却觉得“为什么不呢?”,确实没什么不好的，只是这些自己造的词不在概念认同的范畴内，需要别人重新去解析。前提信息，这一模型，也在数学逻辑中适用，我们以前做题，总是要写看问题和前提条件是什么。它同样在社会范畴适用。又想起了蔡康永关于买房的那段话，你需要知道自己在食物链上哪个位置，如果你出于食物链底层，那么连你都能看到的机会，那么上游的人可能都已经做过了。还有一个协议的最佳时间，那么就是整个web网络和所有脚本语言。</p><p>2.抽象。人们所能够解决的问题的复杂性直接取决于抽象的类型和质量。</p><p>之前接触编程，总是把抽象往抽象类abstract class上面想了。其实大部分时候谈的抽象含义更宽泛，用语言来解释大概是抽取概念的意思。为什么你看框架或良好项目代码时，会发现层级和概念的定义特别具体，现在看来，应该是编写时就是从抽象的维度入手的，所以会特别有楞次感。抽象，是一种思维模式。把要解决的问题语言描述，抽象成模型，然后逐层分解。这个是用编程的方式解决现实问题的一种通用思路和做法。而且这也应该是最常用的架构设计的一种切入角度。</p><p>3.早期的编程语言，如LISP何APL，都选择考虑世界的某些特定视图（分别对应于“所有问题最终都是列表”或者“所有问题都是算法形式的”）。这些方式对于他们所要解决的特定类型问题都是不错的解决方案，但是一旦超出其特定领域，它们就力不从心了。</p><p>这句话立足点非常高，也解答了我一直以来的一个疑惑。我一直觉得很多理论和分析都是立足于某一个角度展开的，很多事情，你从一个方向上选定一个角度就能够去解析它的契合性，而真正做事时，你是需要从千百个角度中选一个能契合的角度的。一个是只要尝试就能正确另外一个是可能只有一次选择的机会，既然如此，那么角度性的理论分析和学习又有什么用呢？这句话给出了这个问题的答案。角度分析对于特定的问题可能是很好的解决方案，虽然超出它们领域时无法适用。（回看这句话感觉特别简单  [-囧-]）</p><p>4.面向对象程序设计的挑战之一，就是在问题空间的元素和解空间的对象之间创建一对一的映射。</p><p>5.良好的面向对象设计中，每个对象都可以很好地完成一项任务，但是它并不试图做更多的事。</p><p>6.讲程序开发人员按照角色分成类创建者（那些创建新数据类型的程序员）和客户端程序员（那些在其应用中适用数据类型的类消费者）是大有裨益的。</p><p>7.一旦类被创建并测试完，那么它就应该（在理想情况下）代表一个有用的代码单元。（轮子）</p><p>8.为了执行后期绑定，Java适用一小段特殊代码来替代绝对地址调用。这段代码适用再对象中存储的信息来计算方法的地址（第八章里解释）</p><p>9.单根集成结构（都是源于一个object，多么恐怖的设计）</p><p>10.从设计的观点来看，真正需要的只有一个可以被操作，从而解决问题的序列。对于容器有所选择的原因，是因为不同容器提供了不同类型的接口和外部行为。不同的容器对于某些操作有不同的效率。</p><p>11.Java SE5的重大变化之一就是增加了参数化类型。</p><p>12.因为存储空间是在运行时被动态管理的，所以需要大量的时间在堆中分配存储空间，这可能要远远大于在堆栈中创建存储空间的时间。（这里和我以前做游戏开发时面临一个同样的问题，如何高频对于体量大的结构的查询和修改）</p><p>13.把问题分成多个可独立运行的部分（任务），从而提高程序的响应能力。在程序中，这些彼此独立运行的部分称之为线程，上述概念被称为“并发”。Java的并发是内置于语言中的，JavaSE5已结增添了大量额外的库支持。</p><p>14.为了将延迟最小化，程序员努力减轻处理任务的负载，通常是分散给客户端机器处理，但有时也会使用所谓的中间件将负载分散给在服务器端的其他机器。（中间件也被用来提高可维护性）</p><p>15.Web实际上就是一个巨型客户/服务器系统，但稍微差一点，因为所有的服务器和客户机器都同时共存于同一个网络中。</p><p>16.程序员通过定义类来适应问题，而不再被迫只能适用鲜有的用来表示机器中的存储单元的数据类型。</p><p><br></p><p>这一章节所讲述的主要内容是：</p><p>1.1 抽象过程。</p><p>这里的意思是，所有编程语言都是一种抽象衍生（这里觉得文本翻译出的 所有编程语言都提供抽象机制 并不准确）。特定视图语言的局限性，以及Java想通过对象这一思想来突破这种局限性以满足更广泛的领域适用。再介绍Java基于的Smalltalk语言面向对象思想的5个特性。（再次感叹一下学习翻译版的局限性。通过翻译版来学习那么就只能站在翻译版的角度思考问题了。）</p><p>1.2每个对象都有一个接口</p><p>这里是介绍类的由来。</p><p>1.3每个对象都提供服务</p><p>内聚性</p><p>1.4被隐藏的具体实现</p><p>通过访问参数或接口封装</p><p>1.5复用具体实现</p><p>has-a（组合）</p><p>1.6继承</p><p>extends overriding</p><p>1.7伴随多台的可互换对象</p><p>后期绑定的概念。</p><p>1.8单根继承结构</p><p>这种设计简化了垃圾回收器的实现</p><p>1.9容器</p><p>提供多种容器支持的原因，参数化类型（Java SE5开始）</p><p>1.10对象的创建和生命期</p><p>对比c++和Java，Java完全采用了动态内存分配方式</p><p>1.11异常处理：处理错误</p><p>异常处理不是面向对象的特性，在之前就有</p><p>1.12并发编程</p><p>Java SE5开始添加大量额外支持。</p><p>1.13Java与Internet</p><p>1.13.1Web是什么</p><p>1.客户/服务器计算技术</p><p>2.Web就是一台巨型服务器</p><p>1.13.2客户端编程</p><p>1.插件</p><p>2.脚本语言</p><p>3.Java（applet）</p><p>4.备选方案（Flex）</p><p>5.net和C#（与Java的竞争）</p><p>6.Internet与Intranet（企业内部网）</p><p>1.13.3服务器端编程</p><p>1.14总结</p>
        </div>
      </div>
    </div>
  </body>
</html>
